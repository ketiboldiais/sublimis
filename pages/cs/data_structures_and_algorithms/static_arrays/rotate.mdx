import { Sequence } from "@illus/Sequence";

<Metadata
	title={"Array Rotation"}
	description={"How to rotate array elements."}
	keywords={
		"arrays, static arrays, rotation, sequences, data structures and algorithms."
	}
/>

# Rotating an Array

Suppose performed a left-shift, pushing the element ${6}$ out of the array.
What if we wanted to keep the ${6}$ somehow? To do so, we use the
`leftRotate()` operator. Starting with this array:

<Sequence data={[6, 3, 8, 5, 9]} />

`leftRotate()` yields:

<Sequence data={[3, 8, 5, 9, 6]} />

Notice that the element ${6}$ moves to ${i = length}$ when the left-shift
pushes it out of the array. The same operation extends to rotating to the
rightâ€”`rightRotate()`. Starting with:

<Sequence data={[6, 3, 8, 5, 9]} />

`rightRotate()` yields:

<Sequence data={[9, 6, 3, 8, 5]} />

Implementing rotate follows cleanly from our implementations for shifting.
All we must do is save the element pushed out of the array in a `temp`
variable, then assign it to the resulting empty space. First, the operation
`leftRotate()`:

```rust
leftRotate():
	temp = A[0]
	for (int i = 0; i < length-1; i++):
		array[i] = array[i+1];
	arr[length-1] = temp;
```

Second, the operation `rightRotate()`:

```rust
rightRotate():
	temp = A[length]
	for (int i = length-1; i > 0; i--):
		array[i] = array[i-1];
	arr[0] = temp;
```

The implementation above is similar to the shifting operations; the only
difference is the inclusion of one more operation, saving the element
popped off the array. Accordingly, both `leftRotate()` and `rightRotate()`
have a time complexity of ${O(n).}$
