import { Sequence } from "@illus/Sequence";

<Metadata
	title={"Reversal"}
	description={"How to reverse the elements of an array."}
	keywords={
		"arrays, sequences, static arrays, reversing, data structures and algorithms"
	}
/>

# Reversing Array Elements

The `reverse()` operator performs exactly what it sounds like: It reverses
all the original elements of the array. For example, given the array:

<Sequence data={[8, 3, 9, 15, 6, 10, 7, 2, 12, 14]} />

`reverse()` returns the array:

<Sequence data={[14, 12, 2, 7, 10, 6, 15, 9, 3, 8]} />

To reverse an array, there are two methods we can use: (1) _reversing in
place_ and (2) using an _auxiliary array_. We first consider the latter.

## Reversing with an Auxiliary Array

With the auxiliary array approach, we use an additional array to place the
reversed elements. The idea is straightforward: We start at the last
element of the array and traverse to the first element, copying each
element to the auxiliary array. After copying all of the elements into the
auxiliary array, we then replace the corresponding elements in the original
array with the elements in the auxiliary array. Implementing this approach
in pseudocode:

```rust
reverse():
	for (i = length - 1, j = 0; i >= 0; i--, j++):
		auxiliaryArr[j] = originalArr[i];
	for (i = 0; i < lenght; i++):
		originalArr[i] = auxiliaryArr[j];
```

What is this approach's time complexity? Copying the elements from the
original array to the auxiliary array takes ${n}$ operations, since we must
traverse through ${n}$ elements. Then, copying the elements from the
auxiliary array back to the original array takes ${n}$ operations, again
because we must traverse through ${n}$ elements. Accordingly, this approach
has a time function of roughly ${f(n) = 2n.}$ Asymptotically, the approach
has a time complexity of order ${O(n)}$â€”linear time.

## Reversing in Place

With the reverse-in-place approach, we swap the first and the last
elements, then the second and the second to last, then the third and the
third to last, and so on. This is done by assigning two indexing variables:
${i}$ to track indices offsetting from and including the first element, and
${j}$ to track indices offsetting from and including the last element. We
continue the process until either ${i}$ and ${j}$ have arrived at the same
index, or when ${i > j.}$ The implementation:

```rust
reverse():
	for (i = 0, j = length - 1; i < j; i++, j--):
		temp = A[i];
		A[i] = A[j];
		A[j] = temp;
```

With the implementation above, we can see that this approach also requires
traversing through the array's ${n}$ elements. Accordingly, this approach,
too, has a running time of ${O(n);}$ linear time.
