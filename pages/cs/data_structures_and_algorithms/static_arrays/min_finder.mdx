import { Sequence } from "@illus/Sequence";

<Metadata
	title={"Minimum Finder"}
	description={"How to find the minimum of an array."}
	keywords={"Static arrays, minimum, data structures and algorithms."}
/>

# Minimum Finder

The `min()` operator returns the minimum element in the array. Finding a
minimum is an instance of a **valley-finding problem**. We can think of it
as the inverse of finding a maximum. Like peak-finding, how efficiently we
can find a minimum depends on whether the array's elements are sorted. If
the elements are unsorted, then we have no recourse other than to use a
linear search approach.

Suppose we had the same array from the previous section:

<Sequence data={[8, 3, 9, 15, 6, 10, 7, 2, 12, 14]} />

The valley here is the element ${u_7 = 2.}$ To find this element, we start
by assuming the first element, ${u_0,}$ is the minimum. We then check if
${u_1 < u_0.}$ If it is, then the minimum is ${u_1,}$ and we compare that
to ${u_2.}$ If it isn't, then the minimum remains ${u_0,}$ and we compare
it against ${u_2.}$ We repeat this process all the way up to the last
element. In pseudocode:

```rust
min():
	min = u[0]
	for (i = 1; i < length; i++):
		if (u[i] < min):
			min = u[i]
	return min
```

Examining the operation count above, we again see that the running time
function is ${f(n) = 1 + n + (n - 1) + 1 = 2n + 1.}$ Accordingly, this
approach also has a time complexity of ${O(n)}$â€”linear time.
